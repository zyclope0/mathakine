#!/usr/bin/env python3
"""
Script de cr√©ation de l'utilisateur permanent ObiWan
Approche acad√©mique pour remplacer l'ancien utilisateur test_user par un utilisateur permanent et distinct.

Fonctionnalit√©s :
1. Cr√©ation s√©curis√©e de l'utilisateur ObiWan avec mot de passe d√©fini
2. V√©rification de l'unicit√© et gestion des conflits
3. Configuration pour les tests et l'interface de connexion
4. Int√©gration avec le syst√®me de nettoyage automatique (pr√©servation)
5. Logs d√©taill√©s et gestion d'erreurs robuste
"""

import sys
import os
import bcrypt
import argparse
from datetime import datetime, timezone
from pathlib import Path

# Ajouter le r√©pertoire racine au path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv

from app.models.user import User, UserRole
from app.utils.db_helpers import get_enum_value, adapt_enum_for_db
from app.db.base import get_db
from app.core.logging_config import get_logger

logger = get_logger(__name__)

class ObiWanUserManager:
    """
    Gestionnaire pour la cr√©ation et maintenance de l'utilisateur permanent ObiWan.
    Impl√©mente une approche acad√©mique avec validation compl√®te.
    """
    
    # Configuration de l'utilisateur ObiWan
    OBIWAN_CONFIG = {
        'username': 'ObiWan',
        'email': 'obiwan.kenobi@jedi-temple.sw',
        'password': 'HelloThere123!',  # Mot de passe distinct et m√©morable
        'full_name': 'Obi-Wan Kenobi',
        'role': UserRole.MAITRE,
        'grade_level': 12,
        'is_permanent': True  # Marqueur pour le syst√®me de nettoyage
    }
    
    def __init__(self):
        """Initialise le gestionnaire avec la configuration de base de donn√©es."""
        load_dotenv()
        self.database_url = os.getenv('DATABASE_URL')
        if not self.database_url:
            raise ValueError("‚ùå Variable DATABASE_URL non trouv√©e dans .env")
        
        self.engine = create_engine(self.database_url)
        self.SessionLocal = sessionmaker(bind=self.engine)
        
        # Masquer les informations sensibles pour l'affichage
        display_url = self.database_url.split('@')[1] if '@' in self.database_url else 'locale'
        logger.info(f"üîó Connexion √† la base : {display_url}")
    
    def generate_password_hash(self, password: str) -> str:
        """
        G√©n√®re un hash bcrypt s√©curis√© pour le mot de passe.
        
        Args:
            password: Mot de passe en clair
            
        Returns:
            Hash bcrypt du mot de passe
        """
        salt = bcrypt.gensalt(rounds=12)  # 12 rounds pour un bon √©quilibre s√©curit√©/performance
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    def verify_password(self, password: str, hashed: str) -> bool:
        """
        V√©rifie qu'un mot de passe correspond au hash.
        
        Args:
            password: Mot de passe en clair
            hashed: Hash bcrypt
            
        Returns:
            True si le mot de passe correspond
        """
        return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))
    
    def check_existing_user(self) -> dict:
        """
        V√©rifie si l'utilisateur ObiWan existe d√©j√†.
        
        Returns:
            Dict avec les informations de l'utilisateur existant ou None
        """
        with self.SessionLocal() as session:
            try:
                query = text("SELECT id, username, email, hashed_password, role FROM users WHERE username = :username")
                result = session.execute(query, {"username": self.OBIWAN_CONFIG['username']}).fetchone()
                
                if result:
                    return {
                        'id': result[0],
                        'username': result[1],
                        'email': result[2],
                        'hashed_password': result[3],
                        'role': result[4],
                        'exists': True
                    }
                return {'exists': False}
                
            except Exception as e:
                logger.error(f"‚ùå Erreur lors de la v√©rification : {str(e)}")
                return {'exists': False, 'error': str(e)}
    
    def create_obiwan_user(self, force_recreate: bool = False) -> dict:
        """
        Cr√©e l'utilisateur ObiWan avec toutes les validations n√©cessaires.
        
        Args:
            force_recreate: Si True, supprime et recr√©e l'utilisateur s'il existe
            
        Returns:
            Dict avec le r√©sultat de l'op√©ration
        """
        logger.info("üöÄ D√©but de la cr√©ation de l'utilisateur ObiWan...")
        
        # V√©rifier si l'utilisateur existe d√©j√†
        existing = self.check_existing_user()
        
        if existing.get('exists', False) and not force_recreate:
            logger.info(f"‚úÖ L'utilisateur ObiWan existe d√©j√† (ID: {existing['id']})")
            
            # V√©rifier si le mot de passe est correct
            if self.verify_password(self.OBIWAN_CONFIG['password'], existing['hashed_password']):
                logger.info("‚úÖ Mot de passe v√©rifi√© - Utilisateur pr√™t √† l'emploi")
                return {
                    'success': True,
                    'action': 'verified',
                    'user_id': existing['id'],
                    'message': 'Utilisateur ObiWan v√©rifi√© et op√©rationnel'
                }
            else:
                logger.warning("‚ö†Ô∏è Mot de passe incorrect - Mise √† jour n√©cessaire")
                return self._update_password(existing['id'])
        
        elif existing.get('exists', False) and force_recreate:
            logger.info("üîÑ Suppression de l'utilisateur existant pour recr√©ation...")
            self._delete_existing_user(existing['id'])
        
        # Cr√©er le nouvel utilisateur
        return self._create_new_user()
    
    def _update_password(self, user_id: int) -> dict:
        """Met √† jour le mot de passe de l'utilisateur existant."""
        with self.SessionLocal() as session:
            try:
                new_hash = self.generate_password_hash(self.OBIWAN_CONFIG['password'])
                
                update_query = text("""
                    UPDATE users 
                    SET hashed_password = :password, updated_at = :updated_at 
                    WHERE id = :user_id
                """)
                
                session.execute(update_query, {
                    "password": new_hash,
                    "updated_at": datetime.now(timezone.utc),
                    "user_id": user_id
                })
                session.commit()
                
                logger.info(f"‚úÖ Mot de passe mis √† jour pour ObiWan (ID: {user_id})")
                return {
                    'success': True,
                    'action': 'password_updated',
                    'user_id': user_id,
                    'message': 'Mot de passe ObiWan mis √† jour avec succ√®s'
                }
                
            except Exception as e:
                session.rollback()
                logger.error(f"‚ùå Erreur lors de la mise √† jour du mot de passe : {str(e)}")
                return {
                    'success': False,
                    'error': str(e),
                    'message': '√âchec de la mise √† jour du mot de passe'
                }
    
    def _delete_existing_user(self, user_id: int):
        """Supprime l'utilisateur existant et ses donn√©es associ√©es."""
        with self.SessionLocal() as session:
            try:
                # Supprimer en respectant les contraintes FK
                delete_queries = [
                    "DELETE FROM logic_challenge_attempts WHERE user_id = :user_id",
                    "DELETE FROM attempts WHERE user_id = :user_id",
                    "DELETE FROM recommendations WHERE user_id = :user_id",
                    "DELETE FROM progress WHERE user_id = :user_id",
                    "DELETE FROM exercises WHERE creator_id = :user_id",
                    "DELETE FROM logic_challenges WHERE creator_id = :user_id",
                    "DELETE FROM users WHERE id = :user_id"
                ]
                
                for query in delete_queries:
                    result = session.execute(text(query), {"user_id": user_id})
                    if result.rowcount > 0:
                        logger.info(f"  üóëÔ∏è Supprim√© {result.rowcount} √©l√©ments : {query.split()[2]}")
                
                session.commit()
                logger.info(f"‚úÖ Utilisateur existant supprim√© (ID: {user_id})")
                
            except Exception as e:
                session.rollback()
                logger.error(f"‚ùå Erreur lors de la suppression : {str(e)}")
                raise
    
    def _create_new_user(self) -> dict:
        """Cr√©e un nouvel utilisateur ObiWan."""
        with self.SessionLocal() as session:
            try:
                # G√©n√©rer le hash du mot de passe
                password_hash = self.generate_password_hash(self.OBIWAN_CONFIG['password'])
                
                # Adapter le r√¥le pour PostgreSQL
                adapted_role = adapt_enum_for_db("UserRole", self.OBIWAN_CONFIG['role'].value, session)
                
                # Pr√©parer les donn√©es utilisateur
                user_data = {
                    'username': self.OBIWAN_CONFIG['username'],
                    'email': self.OBIWAN_CONFIG['email'],
                    'hashed_password': password_hash,
                    'full_name': self.OBIWAN_CONFIG['full_name'],
                    'role': adapted_role,  # Utiliser la valeur adapt√©e
                    'grade_level': self.OBIWAN_CONFIG['grade_level'],
                    'is_active': True,
                    'created_at': datetime.now(timezone.utc),
                    'updated_at': datetime.now(timezone.utc)
                }
                
                # Ins√©rer l'utilisateur
                insert_query = text("""
                    INSERT INTO users (username, email, hashed_password, full_name, role, grade_level, is_active, created_at, updated_at)
                    VALUES (:username, :email, :hashed_password, :full_name, :role, :grade_level, :is_active, :created_at, :updated_at)
                    RETURNING id
                """)
                
                result = session.execute(insert_query, user_data)
                user_id = result.fetchone()[0]
                session.commit()
                
                logger.info(f"üéâ Utilisateur ObiWan cr√©√© avec succ√®s (ID: {user_id})")
                logger.info(f"üìß Email : {self.OBIWAN_CONFIG['email']}")
                logger.info(f"üîë Mot de passe : {self.OBIWAN_CONFIG['password']}")
                logger.info(f"üëë R√¥le : {self.OBIWAN_CONFIG['role'].value}")
                
                # V√©rifier la cr√©ation
                verification = self.verify_user_creation(user_id)
                
                return {
                    'success': True,
                    'action': 'created',
                    'user_id': user_id,
                    'verification': verification,
                    'credentials': {
                        'username': self.OBIWAN_CONFIG['username'],
                        'password': self.OBIWAN_CONFIG['password']
                    },
                    'message': 'Utilisateur ObiWan cr√©√© et v√©rifi√© avec succ√®s'
                }
                
            except Exception as e:
                session.rollback()
                logger.error(f"‚ùå Erreur lors de la cr√©ation : {str(e)}")
                return {
                    'success': False,
                    'error': str(e),
                    'message': '√âchec de la cr√©ation de l\'utilisateur ObiWan'
                }
    
    def verify_user_creation(self, user_id: int) -> dict:
        """
        V√©rifie que l'utilisateur a √©t√© cr√©√© correctement.
        
        Args:
            user_id: ID de l'utilisateur √† v√©rifier
            
        Returns:
            Dict avec les r√©sultats de la v√©rification
        """
        with self.SessionLocal() as session:
            try:
                query = text("""
                    SELECT username, email, role, is_active, created_at 
                    FROM users WHERE id = :user_id
                """)
                result = session.execute(query, {"user_id": user_id}).fetchone()
                
                if not result:
                    return {'success': False, 'error': 'Utilisateur non trouv√© apr√®s cr√©ation'}
                
                # V√©rifier le mot de passe
                password_query = text("SELECT hashed_password FROM users WHERE id = :user_id")
                password_result = session.execute(password_query, {"user_id": user_id}).fetchone()
                
                password_valid = self.verify_password(
                    self.OBIWAN_CONFIG['password'], 
                    password_result[0]
                )
                
                return {
                    'success': True,
                    'username': result[0],
                    'email': result[1],
                    'role': result[2],
                    'is_active': result[3],
                    'created_at': result[4],
                    'password_valid': password_valid
                }
                
            except Exception as e:
                logger.error(f"‚ùå Erreur lors de la v√©rification : {str(e)}")
                return {'success': False, 'error': str(e)}
    
    def generate_login_info(self) -> dict:
        """
        G√©n√®re les informations de connexion pour l'interface.
        
        Returns:
            Dict avec les informations de connexion
        """
        return {
            'username': self.OBIWAN_CONFIG['username'],
            'password': self.OBIWAN_CONFIG['password'],
            'email': self.OBIWAN_CONFIG['email'],
            'display_name': self.OBIWAN_CONFIG['full_name'],
            'role': self.OBIWAN_CONFIG['role'].value,
            'login_url': '/login',
            'dashboard_url': '/dashboard'
        }


def main():
    """Fonction principale avec gestion des arguments."""
    parser = argparse.ArgumentParser(
        description="Cr√©ation de l'utilisateur permanent ObiWan",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation :
  python scripts/create_obiwan_user.py                    # Cr√©ation normale
  python scripts/create_obiwan_user.py --force           # Recr√©ation forc√©e
  python scripts/create_obiwan_user.py --verify-only     # V√©rification seulement
  python scripts/create_obiwan_user.py --show-credentials # Afficher les identifiants
        """
    )
    
    parser.add_argument(
        '--force', '-f',
        action='store_true',
        help='Force la recr√©ation m√™me si l\'utilisateur existe'
    )
    
    parser.add_argument(
        '--verify-only', '-v',
        action='store_true',
        help='V√©rifie seulement l\'existence et la validit√© de l\'utilisateur'
    )
    
    parser.add_argument(
        '--show-credentials', '-c',
        action='store_true',
        help='Affiche les identifiants de connexion'
    )
    
    args = parser.parse_args()
    
    try:
        manager = ObiWanUserManager()
        
        if args.show_credentials:
            # Afficher les identifiants
            info = manager.generate_login_info()
            print("\nüîë IDENTIFIANTS DE CONNEXION OBIWAN")
            print("=" * 40)
            print(f"üë§ Nom d'utilisateur : {info['username']}")
            print(f"üîê Mot de passe      : {info['password']}")
            print(f"üìß Email            : {info['email']}")
            print(f"üëë R√¥le             : {info['role']}")
            print(f"üåê URL de connexion : {info['login_url']}")
            print("=" * 40)
            return
        
        if args.verify_only:
            # V√©rification seulement
            existing = manager.check_existing_user()
            if existing.get('exists', False):
                print(f"‚úÖ L'utilisateur ObiWan existe (ID: {existing['id']})")
                
                # V√©rifier le mot de passe
                if manager.verify_password(manager.OBIWAN_CONFIG['password'], existing['hashed_password']):
                    print("‚úÖ Mot de passe valide")
                else:
                    print("‚ùå Mot de passe invalide - Mise √† jour recommand√©e")
                    print("üí° Utilisez --force pour corriger")
            else:
                print("‚ùå L'utilisateur ObiWan n'existe pas")
                print("üí° Lancez sans --verify-only pour le cr√©er")
            return
        
        # Cr√©ation/mise √† jour de l'utilisateur
        print("üöÄ Cr√©ation de l'utilisateur permanent ObiWan...")
        print(f"üîÑ Mode force : {'Activ√©' if args.force else 'D√©sactiv√©'}")
        print()
        
        result = manager.create_obiwan_user(force_recreate=args.force)
        
        if result['success']:
            print(f"\nüéâ SUCC√àS : {result['message']}")
            print(f"üÜî Action effectu√©e : {result['action']}")
            print(f"üî¢ ID utilisateur : {result['user_id']}")
            
            if 'credentials' in result:
                creds = result['credentials']
                print(f"\nüîë IDENTIFIANTS DE CONNEXION :")
                print(f"   üë§ Utilisateur : {creds['username']}")
                print(f"   üîê Mot de passe : {creds['password']}")
            
            if 'verification' in result and result['verification']['success']:
                verif = result['verification']
                print(f"\n‚úÖ V√âRIFICATION R√âUSSIE :")
                print(f"   üìß Email : {verif['email']}")
                print(f"   üëë R√¥le : {verif['role']}")
                print(f"   üîë Mot de passe : {'Valide' if verif['password_valid'] else 'Invalide'}")
                print(f"   üìÖ Cr√©√© le : {verif['created_at']}")
            
            print(f"\nüåê L'utilisateur ObiWan est pr√™t pour :")
            print(f"   ‚Ä¢ Tests automatis√©s")
            print(f"   ‚Ä¢ Interface de connexion")
            print(f"   ‚Ä¢ D√©veloppement local")
            print(f"   ‚Ä¢ D√©monstrations")
            
        else:
            print(f"\n‚ùå √âCHEC : {result['message']}")
            if 'error' in result:
                print(f"üí• Erreur : {result['error']}")
            sys.exit(1)
            
    except Exception as e:
        logger.error(f"‚ùå Erreur critique : {str(e)}")
        print(f"\nüí• Erreur critique : {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main() 